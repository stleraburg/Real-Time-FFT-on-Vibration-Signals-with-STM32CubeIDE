# Real-Time-FFT-on-Vibration-Signals-with-STM32CubeIDE
## This project employs two ADXL335 analog accelerometers to measure vibrations generated by an ERM vibration motor. The microcontroller programming is done using STM32 Cube IDE software, while STM32 Cube Monitor is utilized to visualize real-time FFT charts.

Requirements:
* Hardware: STM32F5 Discovery Board, LM386 audio amplifier for ERM vibration motor, two ADXL335 accelerometers, MicroSD card adapter.
* Software: STM32CubeIDE, STM32CubeMonitor.

## The code consists of several parts:

1. Sine wave generation.
* Generate the [lookup table](https://www.daycounter.com/Calculators/Sine-Generator-Calculator.phtml) as sample points of a sinusoid for a complete cycle. The more sample points, the better the output waveform.
* Transfer the points from the lookup table to the DAC output using DMA triggered by a timer.
* Formula for controlling the output frequency:

  $\frac{F_(clk)}{Ns \times PSC \times ARR}$

For example, to generate a sine wave with a frequency of 200Hz, configure the clock frequency to 80MHz, Prescaler (PSC) to 80, AutoReload Register (ARR) to 39, and generate 128 sample points.

  ![freq](https://github.com/stleraburg/Real-Time-FFT-on-Vibration-Signals-with-STM32CubeIDE/assets/94596396/4cdedccf-e62e-492d-9647-ce3a68cb41dd)

2. Collecting raw data from two accelerometers.
I use internal ADC2 and ADC3 to sample accelerometer data with DMA transfer. Two buffers for each accelerometer are created. DMA half-full callback function triggered when the first half of the buffers is filled, indicating data readiness for processing. Meanwhile, the second half of the buffers continues being filled.

  The ADCs are triggered by a timer so that we can control the sampling frequency. 

  $f_s = \frac{F_(clk)}{PSC \times ARR}$ 

![adc](https://github.com/stleraburg/Real-Time-FFT-on-Vibration-Signals-with-STM32CubeIDE/assets/94596396/ad9848f2-18eb-47db-8ea2-a7f732a9a944)


![tim](https://github.com/stleraburg/Real-Time-FFT-on-Vibration-Signals-with-STM32CubeIDE/assets/94596396/44e5ad2b-ad3e-4f94-857e-496c7d16a033)


3. Real-time FFT analysis using [double buffering](https://www.eetimes.com/fundamentals-of-embedded-audio-part-3/) technique.
Double Buffering is an efficient way to process the ADC data using DMA transfer. After the DMA engine completes its operation on the first part of the double buffers, it proceeds to move data into "in1" and out of "out1." Meanwhile,       the core simultaneously handles data processing from "in0" and transfers it to "out0."

   ![media-1067218-adifigure11](https://github.com/stleraburg/Real-Time-FFT-on-Vibration-Signals-with-STM32CubeIDE/assets/94596396/aea594c3-d95a-42a9-9bc8-8986369a8f58)

The size of the ADC buffer and FFT buffer can be different to accommodate independent filling and processing. 

CNSIS DSP library is useful in this case as it is enough to use one function to perform FFT. You need to download files and properly configure the program, which is already done in this project. 
```
arm_rfft_fast_f32(&S, fftBufIn, fftBufOut, 0);
```
The function takes the real-valued input buffer and returns the output buffer which is filled with complex numbers. Because we need to convert these numbers to absolute values (because we want to get the magnitude and the phase) we get the half of the output buffer length. The function below computes the magnitudes of these complex numbers and outputs them in fftBufOut. 

```
arm_cmplx_mag_f32(fftBufOut, fftBufOut, FFT_BUFFER_SIZE / 2);
```
For two accelerometers, we need to create two FFT instances. 

4. Printing dominant frequencies with printf().
If we want to use printf() function (which also requires some [configuration](https://www.youtube.com/watch?v=iR34qmfyZtU&t=116s) in the program), we need to calculate the maximum frequency either by using
```
arm_max_f32(fftBufOut, FFT_BUFFER_SIZE, &peakVal, &freq);
printf("Magnitude: %f, Frequency: %lu \n", peakVal,freq);
```
or itterating and comparing the current value with the previous one using. 

5. Saving signals in .csv file on micro SD card for the further analysis.
MicroSD card adapter and STM32 communicate via SPI interface. [This website](https://controllerstech.com/sd-card-using-spi-in-stm32) explains how to configure the mictrocontroller to mount the card, write, read, create, and delete files.   
## Visualization in STM32CubeMonitor 
STM32CubeMonitor assists in real-time adjustment and troubleshooting of STM32 applications at run-time by reading and visualizing their variables in real-time.

![monitor](https://github.com/stleraburg/Real-Time-FFT-on-Vibration-Signals-with-STM32CubeIDE/assets/94596396/3b882fac-03a8-4fa5-932d-80cce90d6363)

[This video](https://www.youtube.com/watch?v=_tnx1ZxkiY8) explains how to visualize arrays in real-time in this software.

A function node is provided for custom visualization in STM32CubeMonitor:
```
const arrayNames=["fftBufOutRight","fftBufOutLeft"];

let str=msg.payload.variablename;

if (str.indexOf("[")===-1) {return null;} 

let arrayName = str.substring(
    0,
    str.indexOf("[")
);

let arrayIndex = parseInt(str.substring(
    str.indexOf("[")+1,
    str.indexOf("]")
));

let globalArrayName="global"+arrayName;

if (global.get(globalArrayName) === undefined) 
{
    global.set(globalArrayName, []);
}

global.set(globalArrayName+"["+arrayIndex+"]",msg.payload.variabledata[0].y);

if (arrayIndex===9) 
    {
        let tmpArr = [];
        let array_size = global.get(globalArrayName).length;

        if (array_size===0) return null;

        for (let i = 0; i < array_size; i++) {
            tmpArr.push({ "x": i, "y": global.get(globalArrayName+"["+i+"]") })
        }



        msg.payload = [{
            "series": ["signal"],
            "data": [tmpArr],
            "labels": ["myLabel"]
            }]

        for (let i = 0; i < arrayNames.length; i++) 
        if (arrayName===arrayNames[i])       
        {
            let chartMessages = new Array(arrayNames.length).fill(null);
            chartMessages[i]=msg;
            return chartMessages;
        }
    }

return null;
```

### Visualization results

The RIGHT accelerometer measures vibrations at 200Hz, while the LEFT accelerometer measures vibrations at 500Hz.

![FFT](https://github.com/stleraburg/Real-Time-FFT-on-Vibration-Signals-with-STM32CubeIDE/assets/94596396/39552087-4cce-4727-9572-8fc1940f74b2)
